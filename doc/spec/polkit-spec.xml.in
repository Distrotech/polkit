<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- CVSID: $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<!-- THIS FILE IS AUTOGENERATED FROM polkit-spec.xml.in -->

<book id="index">
  <bookinfo>
    <title>PolicyKit 0.1 Specification</title>
    <releaseinfo>Version 0.1</releaseinfo>
    <date>March 28th, 2006</date> <!-- Update this manually -->
    <authorgroup>
      <author>
	<firstname>David</firstname>
	<surname>Zeuthen</surname>
	<affiliation>
	  <address>
	    <email>david@fubar.dk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </bookinfo>
  
  <chapter id="introduction">
    <title>Introduction</title>

    <sect1>
      <title>About</title>

      <para>
	PolicyKit is a system for enabling unprivileged desktop
	applications to invoke privileged methods on system-wide
	components in a controlled manner.
      </para>

    </sect1>
  </chapter>

  <chapter id="operation">
    <title>Theory of operation</title>

    <sect1>
      <title>Privileges</title>

      <para>
	One major concept of the PolicyKit system is the notion of
	privileges; a <emphasis>PolicyKit privilege</emphasis>
	(referred to simply as
	<emphasis>privilege</emphasis> in the following) is something
	that a given user may or may not possess. The thinking behind
	PolicyKit is that privileged system level components offer
	functionality to unprivileged desktop applications as D-BUS
	method calls through the system message bus. In order to have
	a flexible security policy defining the set of users that are
	allowed to invoke a method, the system level component defines
	a set of
	<emphasis>privileges</emphasis>. 
      </para>

    </sect1>

    <sect1>
      <title>Architecture</title>

      <para>
	The PolicyKit system is basically client/server and is
	implemented as the
	system-wide <literal>org.freedesktop.PolicyKit</literal> D-BUS
	service. This D-BUS service serves two purposes
      </para>


      <itemizedlist>
        <listitem>
	  <para>
	    System-level components may used D-BUS methods on this
	    service to determine if a given caller of their methods
	    are privileged.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Desktop level applications may initiate a dialogue with
	    this service to (temporarily) obtain a privilege through
	    authorization.
          </para>
	</listitem>
      </itemizedlist>

      <para>
	In addition, the PolicyKit system includes client side
	libraries and command-line utilities wrapping the D-BUS API of
	the <literal>org.freedesktop.PolicyKit</literal> service.
      </para>

    </sect1>

    <sect1>
      <title>Example</title>

      <para>
	As an example, HAL exports the method <literal>Mount</literal>
	on the
	<literal>org.freedesktop.Hal.Device.Volume</literal> interface
	for each hal device object of
	capability <emphasis>volume</emphasis>. HAL defines a number
	of privileges for mounting
	including <emphasis>hal-storage-fixed-mount</emphasis>
	and <emphasis>hal-storage-removable-mount</emphasis>. Depending
	on the whether the volume stems from a fixed hard disk or a
	hotpluggable/removable drive, HAL requires the calling user to
	possess either
	the <emphasis>hal-storage-fixed-mount</emphasis>
	or <emphasis>hal-storage-removable-mount</emphasis> privilege
	in order to carry out the <literal>Mount</literal> method. 
      </para>

      <para>
	Upon a user invoking the <literal>Mount</literal> method, HAL
	simply asks the <literal>org.freedesktop.PolicyKit</literal>
	D-BUS service if the calling user posses this privilege and if
	this is not the case the <literal>Mount</literal> method
	throws
	the <literal>org.freedesktop.Hal.Device.PermissionDeniedByPolicy</literal>
	exception. Notably, this exception will tell the caller what
	privilege the calling user needs to possess,
	e.g. either <emphasis>hal-storage-fixed-mount</emphasis>
	or <emphasis>hal-storage-removable-mount</emphasis>.
      </para>

      <para>
	Should the <literal>Mount</literal> method fail with the
	exception <literal>PermissionDeniedByPolicy</literal> the
	caller now knows what privilege is required. The caller can
	now initiate a dialogue with the <literal>PolicyKit</literal>
	service to obtain this privilege. This conversation is
	basically equivalent to a PAM authentication; in fact the 
	<literal>PolicyKit</literal> service uses PAM under the hood
	and wraps it in D-BUS calls. For details (like what user to
	authenticate as) see XXX. When the caller obtains the
	privilege (after successful authentication) he can now
	invoke <literal>Mount</literal> and after this succeeds he may
	tell the <literal>PolicyKit</literal> service to release the
	privilege for the user as it is no longer needed. Should the
	process crash while holding a privilege,
	the <literal>PolicyKit</literal> service will be notifed and
	the privilege will automatically be revoked.
      </para>

      <para>
	Hence, <literal>PolicyKit</literal> has the notion of
	both <emphasis>permament</emphasis>
	and <emphasis>temporary</emphasis> privileges. The latter may
	even be restricted such that only callers from the D-BUS
	connection (remember, D-BUS connections has unique names)
	obtaining the privilege may use the obtained privilege.
      </para>

      <para>
	In addition, privileges may be restricted to
	certain <emphasis>resources</emphasis>; this is discussed in
	more detail in XXX.
      </para>

      <para>
	<inlinegraphic fileref="polkit-arch.png" format="PNG"/>
      </para>

      <para>
	The whole example is outlined in the diagram above.
      </para>

    </sect1>
  </chapter>


  <chapter id="resources">
    <title>Resources</title>

    <para>
      PolicyKit allows granting privileges only on
      certain <emphasis>resources</emphasis>. For example, for HAL, it
      is possible to grant the
      privilege <emphasis>hal-storage-fixed-mount</emphasis> to the
      user with uid 500 but only for the HAL device object
      representing e.g. the <literal>/dev/hda3</literal> partition.
    </para>

    <sect1>
      <title>Resource Identifiers</title>
      <para> Resource identifers are prefixed with a name identifying
	what service they belong to. The following resource
	identifiers are defined
      </para>

      <itemizedlist>
        <listitem>
	  <para>
	    <literal>hal://</literal>
	    HAL Unique Device Identifiers also known as HAL UID's. Example: <literal>hal:///org/freedesktop/Hal/devices/volume_uuid_1a28b356_9955_44f9_b268_6ed6639978f5</literal>
          </para>
	</listitem>
      </itemizedlist>

    </sect1>

  </chapter>



  <chapter id="privileges">
    <title>Privileges</title>

    <sect1>
      <title>Privilege Descriptors</title>
      <para>	
	Applications, such as HAL, installs <emphasis>privilege descriptors</emphasis> using the <literal>polkit-policy-descriptor-install</literal> commandline utility. The descriptor contains the following information
      </para>

      <itemizedlist>
        <listitem>
	  <para>
	    Criteria for determining if a given user possess the privilege on a given resource.
          </para>
	</listitem>

        <listitem>
	  <para>
	    What other privileges a given user must also possess.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Information on whether the user can obtain the privilege, and if he can, whether only temporarily or permanently.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Whether a user with the privilege may permanently grant it to other users.
          </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>File Format</title>
      <para>
	A developer of a system-wide application wanting to define a
	privilege must create a privilege descriptor. This is a a
	simple <literal>.ini</literal>-like config file. Here is what
	the skeleton looks like:
      </para>

      <programlisting>
	[Policy]
	RequiredPrivileges=
	Allow=
	Deny=
	CanObtain=
	CanGrant=
	ObtainRequireRoot=
	ObtainPAMService=
      </programlisting>

      <sect2>
	<title><literal>RequiredPrivileges</literal>: Required Privileges</title>
	<para>
	  This is a list of privileges the user must possess in order
	  to possess the given privilege. If the user doesn't possess
	  all of these privileges he is not considered to possess the
	  given privilege. The list may be empty.
	</para>
      </sect2>

      <sect2>
	<title><literal>Allow, Deny</literal>: Criteria for Possesing a Privilege</title>
	<para>
	  Both <literal>Allow</literal> and <literal>Deny</literal>
	  contains lists describing what users are allowed
	  respectively denied the privilege. The elements of in each
	  list are of the form
	  <literal>type:value[:resource]</literal>.  where the last
	  part, resource, may be omitted. The following types are
	  supported:
	</para>
	<itemizedlist>
          <listitem>
	    <para><literal>uid</literal>: Unix user identifer; either
	    a positive integer or Unix username. Special values
	    include <literal>__all__</literal> (for denoting all
	    users) and <literal>__none__</literal> (for denoting no
	    users).</para>
	  </listitem>

          <listitem>
	    <para><literal>gid</literal>: Unix group identifier,
	    either a positive integer or Unix groupname. Special
	    values include <literal>__all__</literal> (for denoting
	    all groups) and <literal>__none__</literal> (for denoting
	    no groups).</para>
	  </listitem>
	</itemizedlist>
	<para>
	  To determine if a given user is allowed for a given
	  privilege (for a given resource), first
	  the <literal>RequiredPrivileges</literal> list is consulted
	  as described above. If the user possess all of the listed
	  privileges, the <literal>Allow</literal> list is now
	  consulted. For each element we it is tested whether the user
	  matches. If there are no elements for which the user is
	  matches, the user is said not to possess the given privilege
	  (for the given resource).
	</para>
	<para>
	  If there is a match in the <literal>Allow</literal> list,
	  the <literal>Deny</literal> list is now consulted. If the
	  user matches any of the elements we know he doesn't possess
	  the given privilege. If no elements match we can conclude
	  that the user indeed possesses the given privilege (for the
	  given resource).
	</para>
	<para>
	  This logic is best described by a few examples
	</para>
	<itemizedlist>

          <listitem>
	    <para>
	      <literal>
		Allow="uid:davidz uid:501:hal:///deviceFoo gid:admins
		uid:502"
	      </literal>
	    </para>
	    <para>
	      <literal>
		Deny="gid:dooders uid:502:hal:///deviceBar"
	      </literal>
	    </para>
	    <para>
		User <literal>davidz</literal> possess this
		privilege. All members of
		the <literal>dooders</literal> group is denied this
		privilege. User 501 is allowed this privilege but only
		on the <literal>hal:///deviceFoo</literal>
		resource. All users in the <literal>admin</literal>
		group posseses the privilege. User 502 is allowed this
		privilege but not on
		the <literal>hal:///deviceBar</literal>
		resource.
	    </para>
	  </listitem>

          <listitem>
	    <para>
	      <literal>
		Allow="uid:__all__"
	      </literal>
	    </para>
	    <para>
	      <literal>
		Deny="gid:normalstaff"
	      </literal>
	    </para>
	    <para>
	        All users expect those in
	        the <literal>normalstaff</literal> group posseses this
	        privilege.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

      
      <sect2>
	<title><literal>CanObtain</literal>: Obtaining Privileges</title>
	<para>
	  This property denotes whether an user can obtain the
	  privilege by authentication. It can assume the values
	  <literal>True</literal> (the user can obtain the privilege
	  permanently), <literal>Temporary</literal> (the user can
	  only obtain the privilege temporarily) and
	  <literal>False</literal> (the user can never obtain the
	  privilege through authentication).
	</para>
	<para>
	  The authentication required are specified in
	  the <literal>ObtainRequireRoot</literal>
	  and <literal>ObtainPAMService</literal> properties.
	</para>
      </sect2>
      
      <sect2>
	<title><literal>CanGrant</literal>: Granting Privileges</title>
	<para>
	  This property (it can assume the
	  values <literal>True</literal> and <literal>False</literal>)
	  describes whether an user with the given privilege can grant
	  it to other users, e.g. modify the <literal>Allow</literal>
	  and <literal>Deny</literal> properties.
	</para>
	<para>
	  The property <literal>CanObtain</literal> needs to have the
	  value <literal>True</literal> if this property assumes the
	  value <literal>True</literal>.
	</para>
      </sect2>

      <sect2>
	<title><literal>ObtainRequireRoot, ObtainPAMService</literal>: Authentication Requirements</title>
	<para>
	  If the property <literal>CanObtain</literal> assumes the
	  value <literal>True</literal>
	  or <literal>Temporary</literal> it means the user can
	  authenticate to gain a privilege.
	</para>
	<para>
	  The <literal>ObtainRequireRoot</literal> property specifies
	  whether authentication requires the super user password
	  (<literal>True</literal>) or the users own password
	  (<literal>False</literal>). In addition, it can be specified
	  what PAM service (for example <literal>pam_rps</literal>) is
	  to be used for authentication through the
	  property <literal>ObtainPAMService</literal>.
	</para>
      </sect2>
      
    </sect1>

    <sect1>
      <title>Privileges defined by PolicyKit</title>
      <para>
	baz
      </para>
    </sect1>

  </chapter>
  
</book>
