<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- CVSID: $Id$ -->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">

<!-- THIS FILE IS AUTOGENERATED FROM polkit-spec.xml.in -->

<book id="index">
  <bookinfo>
    <title>PolicyKit 0.2 Specification</title>
    <releaseinfo>Version 0.2</releaseinfo>
    <date>May 12th, 2006</date> <!-- Update this manually -->
    <authorgroup>
      <author>
	<firstname>David</firstname>
	<surname>Zeuthen</surname>
	<affiliation>
	  <address>
	    <email>david@fubar.dk</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
  </bookinfo>
  
  <chapter id="introduction">
    <title>Introduction</title>

    <sect1>
      <title>About</title>

      <para>
	PolicyKit is a system for enabling unprivileged desktop
	applications to invoke privileged methods on system-wide
	components in a controlled manner.
      </para>

    </sect1>
  </chapter>

  <chapter id="operation">
    <title>Theory of operation</title>

    <sect1>
      <title>Privileges</title>

      <para>
	One major concept of the PolicyKit system is the notion of
	privileges; a <emphasis>PolicyKit privilege</emphasis>
	(referred to simply as
	<emphasis>privilege</emphasis> in the following) is something
	that a given user may or may not possess. The thinking behind
	PolicyKit is that privileged system level components offer
	functionality to unprivileged desktop applications as D-BUS
	method calls through the system message bus. In order to have
	a flexible security policy defining the set of users that are
	allowed to invoke a method, the system level component defines
	a set of
	<emphasis>privileges</emphasis>. 
      </para>

    </sect1>

    <sect1>
      <title>Architecture</title>

      <para>
	The PolicyKit system is basically client/server and is
	implemented as the
	system-wide <literal>org.freedesktop.PolicyKit</literal> D-BUS
	service. This D-BUS service serves two purposes
      </para>


      <itemizedlist>
        <listitem>
	  <para>
	    System-level components may used D-BUS methods on this
	    service to determine if a given caller of their methods
	    are privileged.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Desktop level applications may initiate a dialogue with
	    this service to (temporarily) obtain a privilege through
	    authorization.
          </para>
	</listitem>
      </itemizedlist>

      <para>
	In addition, the PolicyKit system includes client side
	libraries and command-line utilities wrapping the D-BUS API of
	the <literal>org.freedesktop.PolicyKit</literal> service.
      </para>

    </sect1>

    <sect1>
      <title>Example</title>

      <para>
	As an example, HAL exports the method <literal>Mount</literal>
	on the
	<literal>org.freedesktop.Hal.Device.Volume</literal> interface
	for each hal device object of
	capability <emphasis>volume</emphasis>. HAL defines a number
	of privileges for mounting
	including <emphasis>hal-storage-fixed-mount</emphasis>
	and <emphasis>hal-storage-removable-mount</emphasis>. Depending
	on the whether the volume stems from a fixed hard disk or a
	hotpluggable/removable drive, HAL requires the calling user to
	possess either
	the <emphasis>hal-storage-fixed-mount</emphasis>
	or <emphasis>hal-storage-removable-mount</emphasis> privilege
	in order to carry out the <literal>Mount</literal> method. 
      </para>

      <para>
	Upon a user invoking the <literal>Mount</literal> method, HAL
	simply asks the <literal>org.freedesktop.PolicyKit</literal>
	D-BUS service if the calling user possess this privilege and if
	this is not the case the <literal>Mount</literal> method
	throws
	the <literal>org.freedesktop.Hal.Device.PermissionDeniedByPolicy</literal>
	exception. Notably, this exception will tell the caller what
	privilege the calling user needs to possess,
	e.g. either <emphasis>hal-storage-fixed-mount</emphasis>
	or <emphasis>hal-storage-removable-mount</emphasis>.
      </para>

      <para>
	Should the <literal>Mount</literal> method fail with the
	exception <literal>PermissionDeniedByPolicy</literal> the
	caller now knows what privilege is required. The caller can
	now initiate a dialogue with the <literal>PolicyKit</literal>
	service to obtain this privilege. This conversation is
	basically equivalent to a PAM authentication; in fact the 
	<literal>PolicyKit</literal> service uses PAM under the hood
	and wraps it in D-BUS calls. For details (like what user to
	authenticate as) see XXX. When the caller obtains the
	privilege (after successful authentication) he can now
	invoke <literal>Mount</literal> and after this succeeds he may
	tell the <literal>PolicyKit</literal> service to release the
	privilege for the user as it is no longer needed. Should the
	process crash while holding a privilege,
	the <literal>PolicyKit</literal> service will be notifed and
	the privilege will automatically be revoked.
      </para>

      <para>
	Hence, <literal>PolicyKit</literal> has the notion of
	both <emphasis>permament</emphasis>
	and <emphasis>temporary</emphasis> privileges. The latter may
	even be restricted such that only callers from the D-BUS
	connection (remember, D-BUS connections has unique names)
	obtaining the privilege may use the obtained
	privilege. Consequently, if a temporary privilege is
	restricted to a certain D-BUS connection, it is revoked when
	the owner of this connection disconnects from the system
	message bus.
      </para>

      <para>
	In addition, privileges may be restricted to
	certain <emphasis>resources</emphasis>; this is discussed in
	more detail in XXX.
      </para>

      <para>
	<inlinegraphic fileref="polkit-arch.png" format="PNG"/>
      </para>

      <para>
	The whole example is outlined in the diagram above.
      </para>

    </sect1>
  </chapter>


  <chapter id="resources">
    <title>Resources</title>

    <para>
      PolicyKit allows granting privileges only on
      certain <emphasis>resources</emphasis>. For example, for HAL, it
      is possible to grant the
      privilege <emphasis>hal-storage-fixed-mount</emphasis> to the
      user with uid 500 but only for the HAL device object
      representing e.g. the <literal>/dev/hda3</literal> partition.
    </para>

    <sect1>
      <title>Resource Identifiers</title>
      <para> Resource identifers are prefixed with a name identifying
	what service they belong to. The following resource
	identifiers are defined
      </para>

      <itemizedlist>
        <listitem>
	  <para>
	    <literal>hal://</literal>
	    HAL Unique Device Identifiers also known as HAL UID's. Example: <literal>hal:///org/freedesktop/Hal/devices/volume_uuid_1a28b356_9955_44f9_b268_6ed6639978f5</literal>
          </para>
	</listitem>
      </itemizedlist>

    </sect1>

  </chapter>



  <chapter id="privileges">
    <title>Privileges</title>

    <sect1>
      <title>Privilege Descriptors</title>
      <para> 
	Applications, such as HAL, installs <emphasis>privilege
	descriptors</emphasis> into
	the <literal>/etc/PolicyKit/privilege.d</literal> directory
	(or more correct, into
	the <literal>$sysconfdir/PolicyKit/privilege.d</literal>
	directory depending on where PolicyKit is built).
      </para>

      <para>
	A policy descriptor contains the following information:
      </para>

      <itemizedlist>
        <listitem>
	  <para>
	    Criteria for determining if a given user possess the privilege on a given resource.
          </para>
	</listitem>

        <listitem>
	  <para>
	    What privileges are required to possess a given privilege.
          </para>
	</listitem>

        <listitem>
	  <para>
	    What privileges are sufficient to possess to automatically possess a given privilege.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Information on whether the user can obtain the privilege, and if he can, whether only temporarily or permanently.
          </para>
	</listitem>

        <listitem>
	  <para>
	    Whether a user with the privilege may permanently grant it to other users.
          </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>File Format</title>
      <para>
	A developer of a system-wide application wanting to define a
	privilege must create a privilege descriptor. This is a a
	simple <literal>.ini</literal>-like config file. Here is what
	the skeleton looks like:
      </para>

      <programlisting>
	[Policy]
	RequiredPrivileges=
	SufficientPrivileges=
	Allow=
	Deny=
	CanObtain=
	CanGrant=
	ObtainRequireRoot=
      </programlisting>

      <sect2>
	<title><literal>RequiredPrivileges</literal>: Required Privileges</title>
	<para>
	  This is a list of privileges the user must possess in order
	  to possess the given privilege. If the user doesn't possess
	  all of these privileges he is not considered to possess the
	  given privilege. The list may be empty. A privilege in this
	  list is considered being possessed if the user is privileged
	  for one or more resources. E.g., if <literal>foo</literal>
	  is a required privilege then just having this privilege on
	  one resource is sufficient.
	</para>
      </sect2>

      <sect2>
	<title><literal>SufficientPrivileges</literal>: Sufficient Privileges</title>
	<para>
	  This is a list of privileges that, if a user possess any of
	  these, he is consider to possess the given privilege. The
	  list may be empty.  A privilege in this list is considered
	  being possessed if the user is privileged for one or more
	  resources. As with <literal>RequiredPrivileges</literal>,
	  if <literal>foo</literal> is a sufficient privilege then
	  just having this privilege on one resource is sufficient.
	</para>
      </sect2>

      <sect2>
	<title><literal>Allow, Deny</literal>: Criteria for Possesing a Privilege</title>
	<para>
	  Both <literal>Allow</literal> and <literal>Deny</literal>
	  contains lists describing what users are allowed
	  respectively denied the privilege. The elements of in each
	  list are of the form
	  <literal>type:value[:resource]</literal>.  where the last
	  part, resource, may be omitted. The following types are
	  supported:
	</para>
	<itemizedlist>
          <listitem>
	    <para><literal>uid</literal>: Unix user identifer; either
	    a positive integer or Unix username. Special values
	    include <literal>__all__</literal> (for denoting all
	    users) and <literal>__none__</literal> (for denoting no
	    users).</para>
	  </listitem>

          <listitem>
	    <para><literal>gid</literal>: Unix group identifier,
	    either a positive integer or Unix groupname. Special
	    values include <literal>__all__</literal> (for denoting
	    all groups) and <literal>__none__</literal> (for denoting
	    no groups).</para>
	  </listitem>
	</itemizedlist>
	<para>
	  To determine if a given user is allowed for a given
	  privilege (for a given resource), first
	  the <literal>SufficientPrivileges</literal> list is
	  consulted as described above. If the user possesses one or
	  more of the listed privileges we're done; the user is
	  automatically allowed for the given privilege. If this is
	  not the case, the <literal>RequiredPrivileges</literal> list
	  is consulted as described above. If the user possess all of
	  the listed privileges, the <literal>Allow</literal> list is
	  now consulted. For each element it is tested whether the
	  user matches. If there are no elements for which the user is
	  matches, the user is said not to possess the given privilege
	  (for the given resource).
	</para>
	<para>
	  If there is a match in the <literal>Allow</literal> list,
	  the <literal>Deny</literal> list is now consulted. If the
	  user matches any of the elements we know he doesn't possess
	  the given privilege. If no elements match we can conclude
	  that the user indeed possesses the given privilege (for the
	  given resource).
	</para>
	<para>
	  This logic is best described by a few examples
	</para>
	<itemizedlist>

          <listitem>
	    <para>
	      <literal>
		Allow="uid:davidz uid:501:hal:///deviceFoo gid:admins
		uid:502"
	      </literal>
	    </para>
	    <para>
	      <literal>
		Deny="gid:dooders uid:502:hal:///deviceBar"
	      </literal>
	    </para>
	    <para>
		User <literal>davidz</literal> possess this
		privilege. All members of
		the <literal>dooders</literal> group is denied this
		privilege. User 501 is allowed this privilege but only
		on the <literal>hal:///deviceFoo</literal>
		resource. All users in the <literal>admin</literal>
		group posseses the privilege. User 502 is allowed this
		privilege but not on
		the <literal>hal:///deviceBar</literal>
		resource.
	    </para>
	  </listitem>

          <listitem>
	    <para>
	      <literal>
		Allow="uid:__all__"
	      </literal>
	    </para>
	    <para>
	      <literal>
		Deny="gid:normalstaff"
	      </literal>
	    </para>
	    <para>
	        All users expect those in
	        the <literal>normalstaff</literal> group posseses this
	        privilege.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

      
      <sect2 id="can-obtain">
	<title><literal>CanObtain</literal>: Obtaining Privileges</title>
	<para>
	  This property denotes whether an user can obtain the
	  privilege by authentication. This is useful when either
	  either the privilege in question or one of the privileges
	  listed in <literal>RequiredPrivileges</literal> is not
	  possessed.
	</para>

	<para>
	  The property can assume the values
	  <literal>True</literal> (the user can obtain the privilege
	  permanently), <literal>Temporary</literal> (the user can
	  only obtain the privilege temporarily) and
	  <literal>False</literal> (the user can never obtain the
	  privilege through authentication). 
	</para>
	  
	<para>
	  Whether the user needs to autenticate as himself or the
	  super user is specified in
	  the <literal>ObtainRequireRoot</literal> property. Note that
	  if the user is lacking one or more of the privileges listed
	  in <literal>RequiredPrivileges</literal> and one of these
	  has <literal>ObtainRequireRoot=True</literal> the user will
	  have to authenticate as the super user nonwithstanding that
	  the privilege he attempts to obtain
	  has <literal>ObtainRequireRoot=False</literal>. Moreover, if
	  any of the lacking privileges
	  in <literal>RequiredPrivileges</literal>
	  has <literal>CanObtain</literal> set
	  to <literal>False</literal>, the user will always have to
	  authenticate as the super user.
	</para>

      </sect2>
      
      <sect2>
	<title><literal>CanGrant</literal>: Granting Privileges</title>
	<para>
	  This property (it can assume the
	  values <literal>True</literal> and <literal>False</literal>)
	  describes whether an user with the given privilege can
	  permanently grant it to himself and/or other users,.
	</para>
	<para>
	  Typically, the construct is used in the following kind of UI
	  dialogs:
	</para>

	<programlisting>
    +----------------------------------------------------+
    | You are not privileged to access the volume        |
    | 'Dave's USB key'. You need to authenticate as the  |
    | system administrator                               |
    |                                                    |
    |   Super user password: [_______________]           |
    |                                                    |
    |   Would you also like to automatically allow       |
    |                                                    |
    |  (*) This user to mount 'Dave's USB key'           |
    |  ( ) Any user to mount 'Dave's USB key'            |
    |  ( ) This user to mount a removable storage device |
    |  ( ) Any user to mount a removable storage device  |
    |                                                    |
    | [Cancel]                                   [Mount] |
    +----------------------------------------------------+
       (TODO: replace with screenshot from gnome-mount)
	</programlisting>

	<para>
	  The property <literal>CanObtain</literal> needs to assume
	  the value <literal>True</literal> if this property assumes
	  the value <literal>True</literal>. Otherwise this property
	  effectively assumes the value <literal>False</literal>.
	</para>
      </sect2>

      <sect2>
	<title><literal>ObtainRequireRoot</literal>: Authentication Requirements</title>
	<para>
	  If the property <literal>CanObtain</literal> assumes the
	  value <literal>True</literal>
	  or <literal>Temporary</literal> it means the user can
	  authenticate to gain a
	  privilege. The <literal>ObtainRequireRoot</literal> property
	  specifies whether authentication requires the super user
	  password (<literal>True</literal>) or the users own password
	  (<literal>False</literal>).
	</para>
	<para>
	  See <xref linkend="can-obtain"/> for discussion on how
	  the <literal>RequiredPrivileges</literal> property affects
	  the effective value of this property.
	</para>
      </sect2>
      
    </sect1>

    <sect1 id="privs-by-polkit">
      <title>Privileges defined by PolicyKit</title>
      <para>
	This section describe privileges defined by PolicyKit and how
	they can be used by other pieces of software. Some privileges
	have special meaning and affects how PolicyKit works.
      </para>

      <sect2 id="priv-desktop-console">
	<title><literal>desktop-console</literal> : Users at a local console</title>

	<programlisting>
desktop-console.privilege:

# This privilege signfies that users holding it are logged into a
# physical console attached to the system. Thus, it is useful for
# other privileges for manipulating local devices to simply require
# this privilege. 

[Privilege]
RequiredPrivileges=
SufficientPrivileges=
Allow=
Deny=
CanObtain=Temporary
CanGrant=False
ObtainRequireRoot=True
	</programlisting>

	<para>
	  This privilege signifies that the user holding it is logged
	  in at a local console. In this context, "local console"
	  means that the display / keyboard / pointing device is local
	  to the system which implies the user got physical access to
	  the box.
	</para>

	<para>
	  The PAM module <literal>pam-polkit-console</literal> shipped
	  with PolicyKit is used to maintain files
	  in <literal>/var/run/polkit-console</literal> for users
	  logging in and out, and signal the PolicyKit daemon to
	  reread these files and dynamically grant / revoke
	  the <literal>desktop-console</literal> privilege. Typically,
	  graphical login managers such as the GNOME Display Manager
	  (gdm) will want include this in it's stack of PAM modules.
	</para>

	<para>
	  Remote users (e.g. those not at a local console) can obtain
	  the <literal>desktop-console</literal> only by
	  authenticating as the super user.
	</para>

	<para>
	  The <literal>desktop-console</literal> privilege can be used
	  in conjunction with
	  the <literal>RequiredPrivileges</literal> property in a
	  privilege descriptor to ensure only users at a local console
	  is entitled to a privilege for putting a system to sleep
	  without having to autenticate. This is achieved by e.g. this
	  privilege descriptor:
	</para>

	<programlisting>
hal-system-suspend.privilege:

# This privilege specifies who is allowed to suspend the system.

[Privilege]
RequiredPrivileges=desktop-console
SufficientPrivileges=
Allow=uid:__all__
Deny=
CanObtain=True
CanGrant=True
ObtainRequireRoot=False
	</programlisting>

	<para>
	  For a remote user with the
	  privilege <literal>hal-system-suspend</literal> it means
	  that authentication as the super user is required
	  as <literal>desktop-console</literal>
	  has <literal>ObtainRequireRoot=True</literal> and this
	  trumps the <literal>ObtainRequireRoot=False</literal>
	  property that is in
	  the <literal>hal-system-suspend</literal> privilege (see
	  <xref linkend="can-obtain"/>). Of course, if the user is
	  logged in at a local console no authentication is required.
	</para>

	<para>
	  Typically, the <literal>desktop-console</literal> privilege
	  is granted on a specific resource, namely what console the
	  user is logged into. At the time of writing, this resource
	  can only be consider an opaque identifier (such
	  as <literal>console://:0</literal> which refers to X11
	  display ":0") and one cannot assign meaning to it. In the
	  future, it may be possible to assign meaning to it.
	</para>
      </sect2>

    </sect1>

  </chapter>
  
</book>
